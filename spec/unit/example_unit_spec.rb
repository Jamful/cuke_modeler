require 'spec_helper'

SimpleCov.command_name('Example') unless RUBY_VERSION.to_s < '1.9.0'

describe 'Example, Unit' do

  let(:clazz) { CukeModeler::Example }
  let(:example) { clazz.new }

  describe 'common behavior' do

    it_should_behave_like 'a modeled element'
    it_should_behave_like 'a named element'
    it_should_behave_like 'a described element'
    it_should_behave_like 'a tagged element'
    it_should_behave_like 'a sourced element'
    it_should_behave_like 'a raw element'

  end


  describe 'unique behavior' do

    it 'can be parsed from stand alone text' do
      source = ['Examples: test example',
                '|param| ',
                '|value|']

      source = source.join("\n")

      expect { @element = clazz.new(source) }.to_not raise_error

      # Sanity check in case instantiation failed in a non-explosive manner
      @element.name.should == 'test example'
    end

    it 'can be instantiated with the minimum viable Gherkin', :gherkin4 => true do
      source = ['Examples:']
      source = source.join("\n")

      expect { @element = clazz.new(source) }.to_not raise_error
    end

    it 'provides a descriptive filename when being parsed from stand alone text' do
      source = 'bad example text'

      expect { clazz.new(source) }.to raise_error(/'cuke_modeler_stand_alone_example\.feature'/)
    end

    it 'stores the original data generated by the parsing adapter', :gherkin4 => true do
      example = clazz.new("Examples: test example\n|param|\n|value|")
      raw_data = example.raw_element

      expect(raw_data.keys).to match_array([:type, :tags, :location, :keyword, :name, :tableHeader, :tableBody])
      expect(raw_data[:type]).to eq(:Examples)
    end

    it 'stores the original data generated by the parsing adapter', :gherkin3 => true do
      example = clazz.new("Examples: test example\n|param|\n|value|")
      raw_data = example.raw_element

      expect(raw_data.keys).to match_array([:type, :tags, :location, :keyword, :name, :tableHeader, :tableBody])
      expect(raw_data[:type]).to eq(:Examples)
    end

    it 'stores the original data generated by the parsing adapter', :gherkin2 => true do
      example = clazz.new("Examples: test example\n|param|\n|value|")
      raw_data = example.raw_element

      expect(raw_data.keys).to match_array(['keyword', 'name', 'line', 'description', 'id', 'rows'])
      expect(raw_data['keyword']).to eq('Examples')
    end

    it 'has rows' do
      example.should respond_to(:rows)
    end

    it 'can change its rows' do
      expect(example).to respond_to(:rows=)

      example.rows = :some_rows
      expect(example.rows).to eq(:some_rows)
      example.rows = :some_other_rows
      expect(example.rows).to eq(:some_other_rows)
    end

    it 'can selectively access its parameter row' do
      expect(example).to respond_to(:parameter_row)
    end

    it 'can selectively access its argument rows' do
      expect(example).to respond_to(:argument_rows)
    end


    describe 'abstract instantiation' do

      context 'a new example object' do

        let(:example) { clazz.new }


        it 'starts with no rows' do
          expect(example.rows).to eq([])
        end

        it 'starts with no argument rows' do
          expect(example.argument_rows).to eq([])
        end

        it 'starts with no parameter row' do
          expect(example.parameter_row).to be_nil
        end

      end

    end


    it 'can add a new example row' do
      clazz.new.should respond_to(:add_row)
    end

    it 'can remove an existing example row' do
      clazz.new.should respond_to(:remove_row)
    end

    it 'contains rows and tags' do
      tags = [:tag_1, :tag_2]
      rows = [:row_1, :row_2]
      everything = rows + tags

      example.rows = rows
      example.tags = tags

      expect(example.children).to match_array(everything)
    end

    describe 'example output edge cases' do

      it 'is a String' do
        example.to_s.should be_a(String)
      end

      context 'a new example object' do

        let(:example) { clazz.new }


        it 'can output an empty example' do
          expect { example.to_s }.to_not raise_error
        end

        it 'can output an example that has only a name' do
          example.name = 'a name'

          expect { example.to_s }.to_not raise_error
        end

        it 'can output an example that has only a description' do
          example.description = 'a description'

          expect { example.to_s }.to_not raise_error
        end

      end

    end

  end

end
